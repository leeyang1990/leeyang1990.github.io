var Ot=Object.defineProperty;var ot=Object.getOwnPropertySymbols;var vt=Object.prototype.hasOwnProperty,Ct=Object.prototype.propertyIsEnumerable;var at=(e,t,n)=>t in e?Ot(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,$=(e,t)=>{for(var n in t||(t={}))vt.call(t,n)&&at(e,n,t[n]);if(ot)for(var n of ot(t))Ct.call(t,n)&&at(e,n,t[n]);return e};function mt(){}function Tt(e,t){for(const n in t)e[n]=t[n];return e}function yt(e){return e()}function ht(){return Object.create(null)}function T(e){e.forEach(yt)}function jt(e){return typeof e=="function"}function Te(e,t){return e!=e?t==t:e!==t||e&&typeof e=="object"||typeof e=="function"}let K;function je(e,t){return K||(K=document.createElement("a")),K.href=t,e===K.href}function Ft(e){return Object.keys(e).length===0}function Fe(e,t,n,s){if(e){const r=xt(e,t,n,s);return e[0](r)}}function xt(e,t,n,s){return e[1]&&s?Tt(n.ctx.slice(),e[1](s(t))):n.ctx}function Pe(e,t,n,s){if(e[2]&&s){const r=e[2](s(n));if(t.dirty===void 0)return r;if(typeof r=="object"){const i=[],c=Math.max(t.dirty.length,r.length);for(let o=0;o<c;o+=1)i[o]=t.dirty[o]|r[o];return i}return t.dirty|r}return t.dirty}function Ke(e,t,n,s,r,i){if(r){const c=xt(t,n,s,i);e.p(c,r)}}function Be(e){if(e.ctx.length>32){const t=[],n=e.ctx.length/32;for(let s=0;s<n;s++)t[s]=-1;return t}return-1}function De(e){return e==null?"":e}function We(e,t){e.appendChild(t)}function ze(e,t,n){e.insertBefore(t,n||null)}function Pt(e){e.parentNode.removeChild(e)}function He(e,t){for(let n=0;n<e.length;n+=1)e[n]&&e[n].d(t)}function Ve(e){return document.createElement(e)}function Mt(e){return document.createTextNode(e)}function Ye(){return Mt(" ")}function Ge(){return Mt("")}function Ue(e,t,n,s){return e.addEventListener(t,n,s),()=>e.removeEventListener(t,n,s)}function Qe(e,t,n){n==null?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function Kt(e){return Array.from(e.childNodes)}function Xe(e,t){t=""+t,e.wholeText!==t&&(e.data=t)}let st;function C(e){st=e}const v=[],lt=[],W=[],ut=[],Bt=Promise.resolve();let Q=!1;function Dt(){Q||(Q=!0,Bt.then(Et))}function X(e){W.push(e)}const G=new Set;let B=0;function Et(){const e=st;do{for(;B<v.length;){const t=v[B];B++,C(t),Wt(t.$$)}for(C(null),v.length=0,B=0;lt.length;)lt.pop()();for(let t=0;t<W.length;t+=1){const n=W[t];G.has(n)||(G.add(n),n())}W.length=0}while(v.length);for(;ut.length;)ut.pop()();Q=!1,G.clear(),C(e)}function Wt(e){if(e.fragment!==null){e.update(),T(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(X)}}const z=new Set;let R;function Je(){R={r:0,c:[],p:R}}function Ze(){R.r||T(R.c),R=R.p}function zt(e,t){e&&e.i&&(z.delete(e),e.i(t))}function qe(e,t,n,s){if(e&&e.o){if(z.has(e))return;z.add(e),R.c.push(()=>{z.delete(e),s&&(n&&e.d(1),s())}),e.o(t)}}function tn(e){e&&e.c()}function Ht(e,t,n,s){const{fragment:r,on_mount:i,on_destroy:c,after_update:o}=e.$$;r&&r.m(t,n),s||X(()=>{const h=i.map(yt).filter(jt);c?c.push(...h):T(h),e.$$.on_mount=[]}),o.forEach(X)}function Vt(e,t){const n=e.$$;n.fragment!==null&&(T(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function Yt(e,t){e.$$.dirty[0]===-1&&(v.push(e),Dt(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function en(e,t,n,s,r,i,c,o=[-1]){const h=st;C(e);const a=e.$$={fragment:null,ctx:null,props:i,update:mt,not_equal:r,bound:ht(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(h?h.$$.context:[])),callbacks:ht(),dirty:o,skip_bound:!1,root:t.target||h.$$.root};c&&c(a.root);let l=!1;if(a.ctx=n?n(e,t.props||{},(u,d,...g)=>{const p=g.length?g[0]:d;return a.ctx&&r(a.ctx[u],a.ctx[u]=p)&&(!a.skip_bound&&a.bound[u]&&a.bound[u](p),l&&Yt(e,u)),d}):[],a.update(),l=!0,T(a.before_update),a.fragment=s?s(a.ctx):!1,t.target){if(t.hydrate){const u=Kt(t.target);a.fragment&&a.fragment.l(u),u.forEach(Pt)}else a.fragment&&a.fragment.c();t.intro&&zt(e.$$.fragment),Ht(e,t.target,t.anchor,t.customElement),Et()}C(h)}class nn{$destroy(){Vt(this,1),this.$destroy=mt}$on(t,n){const s=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return s.push(n),()=>{const r=s.indexOf(n);r!==-1&&s.splice(r,1)}}$set(t){this.$$set&&!Ft(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}function I(e){return Array.isArray?Array.isArray(e):St(e)==="[object Array]"}const Gt=1/0;function Ut(e){if(typeof e=="string")return e;let t=e+"";return t=="0"&&1/e==-Gt?"-0":t}function Qt(e){return e==null?"":Ut(e)}function E(e){return typeof e=="string"}function It(e){return typeof e=="number"}function Xt(e){return e===!0||e===!1||Jt(e)&&St(e)=="[object Boolean]"}function At(e){return typeof e=="object"}function Jt(e){return At(e)&&e!==null}function _(e){return e!=null}function U(e){return!e.trim().length}function St(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const Zt="Incorrect 'index' type",qt=e=>`Invalid value for key ${e}`,te=e=>`Pattern length exceeds max of ${e}.`,ee=e=>`Missing ${e} property in key`,ne=e=>`Property 'weight' in key '${e}' must be a positive integer`,ft=Object.prototype.hasOwnProperty;class se{constructor(t){this._keys=[],this._keyMap={};let n=0;t.forEach(s=>{let r=wt(s);n+=r.weight,this._keys.push(r),this._keyMap[r.id]=r,n+=r.weight}),this._keys.forEach(s=>{s.weight/=n})}get(t){return this._keyMap[t]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function wt(e){let t=null,n=null,s=null,r=1;if(E(e)||I(e))s=e,t=dt(e),n=J(e);else{if(!ft.call(e,"name"))throw new Error(ee("name"));const i=e.name;if(s=i,ft.call(e,"weight")&&(r=e.weight,r<=0))throw new Error(ne(i));t=dt(i),n=J(i)}return{path:t,id:n,weight:r,src:s}}function dt(e){return I(e)?e:e.split(".")}function J(e){return I(e)?e.join("."):e}function re(e,t){let n=[],s=!1;const r=(i,c,o)=>{if(!!_(i))if(!c[o])n.push(i);else{let h=c[o];const a=i[h];if(!_(a))return;if(o===c.length-1&&(E(a)||It(a)||Xt(a)))n.push(Qt(a));else if(I(a)){s=!0;for(let l=0,u=a.length;l<u;l+=1)r(a[l],c,o+1)}else c.length&&r(a,c,o+1)}};return r(e,E(t)?t.split("."):t,0),s?n:n[0]}const ie={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},ce={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1},oe={location:0,threshold:.6,distance:100},ae={useExtendedSearch:!1,getFn:re,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var f=$($($($({},ce),ie),oe),ae);const he=/[^ ]+/g;function le(e=1,t=3){const n=new Map,s=Math.pow(10,t);return{get(r){const i=r.match(he).length;if(n.has(i))return n.get(i);const c=1/Math.pow(i,.5*e),o=parseFloat(Math.round(c*s)/s);return n.set(i,o),o},clear(){n.clear()}}}class rt{constructor({getFn:t=f.getFn,fieldNormWeight:n=f.fieldNormWeight}={}){this.norm=le(n,3),this.getFn=t,this.isCreated=!1,this.setIndexRecords()}setSources(t=[]){this.docs=t}setIndexRecords(t=[]){this.records=t}setKeys(t=[]){this.keys=t,this._keysMap={},t.forEach((n,s)=>{this._keysMap[n.id]=s})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,E(this.docs[0])?this.docs.forEach((t,n)=>{this._addString(t,n)}):this.docs.forEach((t,n)=>{this._addObject(t,n)}),this.norm.clear())}add(t){const n=this.size();E(t)?this._addString(t,n):this._addObject(t,n)}removeAt(t){this.records.splice(t,1);for(let n=t,s=this.size();n<s;n+=1)this.records[n].i-=1}getValueForItemAtKeyId(t,n){return t[this._keysMap[n]]}size(){return this.records.length}_addString(t,n){if(!_(t)||U(t))return;let s={v:t,i:n,n:this.norm.get(t)};this.records.push(s)}_addObject(t,n){let s={i:n,$:{}};this.keys.forEach((r,i)=>{let c=this.getFn(t,r.path);if(!!_(c)){if(I(c)){let o=[];const h=[{nestedArrIndex:-1,value:c}];for(;h.length;){const{nestedArrIndex:a,value:l}=h.pop();if(!!_(l))if(E(l)&&!U(l)){let u={v:l,i:a,n:this.norm.get(l)};o.push(u)}else I(l)&&l.forEach((u,d)=>{h.push({nestedArrIndex:d,value:u})})}s.$[i]=o}else if(!U(c)){let o={v:c,n:this.norm.get(c)};s.$[i]=o}}}),this.records.push(s)}toJSON(){return{keys:this.keys,records:this.records}}}function bt(e,t,{getFn:n=f.getFn,fieldNormWeight:s=f.fieldNormWeight}={}){const r=new rt({getFn:n,fieldNormWeight:s});return r.setKeys(e.map(wt)),r.setSources(t),r.create(),r}function ue(e,{getFn:t=f.getFn,fieldNormWeight:n=f.fieldNormWeight}={}){const{keys:s,records:r}=e,i=new rt({getFn:t,fieldNormWeight:n});return i.setKeys(s),i.setIndexRecords(r),i}function D(e,{errors:t=0,currentLocation:n=0,expectedLocation:s=0,distance:r=f.distance,ignoreLocation:i=f.ignoreLocation}={}){const c=t/e.length;if(i)return c;const o=Math.abs(s-n);return r?c+o/r:o?1:c}function fe(e=[],t=f.minMatchCharLength){let n=[],s=-1,r=-1,i=0;for(let c=e.length;i<c;i+=1){let o=e[i];o&&s===-1?s=i:!o&&s!==-1&&(r=i-1,r-s+1>=t&&n.push([s,r]),s=-1)}return e[i-1]&&i-s>=t&&n.push([s,i-1]),n}const k=32;function de(e,t,n,{location:s=f.location,distance:r=f.distance,threshold:i=f.threshold,findAllMatches:c=f.findAllMatches,minMatchCharLength:o=f.minMatchCharLength,includeMatches:h=f.includeMatches,ignoreLocation:a=f.ignoreLocation}={}){if(t.length>k)throw new Error(te(k));const l=t.length,u=e.length,d=Math.max(0,Math.min(s,u));let g=i,p=d;const m=o>1||h,b=m?Array(u):[];let M;for(;(M=e.indexOf(t,p))>-1;){let y=D(t,{currentLocation:M,expectedLocation:d,distance:r,ignoreLocation:a});if(g=Math.min(y,g),p=M+l,m){let A=0;for(;A<l;)b[M+A]=1,A+=1}}p=-1;let N=[],L=1,F=l+u;const Nt=1<<l-1;for(let y=0;y<l;y+=1){let A=0,S=F;for(;A<S;)D(t,{errors:y,currentLocation:d+S,expectedLocation:d,distance:r,ignoreLocation:a})<=g?A=S:F=S,S=Math.floor((F-A)/2+A);F=S;let it=Math.max(1,d-S+1),Y=c?u:Math.min(d+S,u)+l,O=Array(Y+2);O[Y+1]=(1<<y)-1;for(let x=Y;x>=it;x-=1){let P=x-1,ct=n[e.charAt(P)];if(m&&(b[P]=+!!ct),O[x]=(O[x+1]<<1|1)&ct,y&&(O[x]|=(N[x+1]|N[x])<<1|1|N[x+1]),O[x]&Nt&&(L=D(t,{errors:y,currentLocation:P,expectedLocation:d,distance:r,ignoreLocation:a}),L<=g)){if(g=L,p=P,p<=d)break;it=Math.max(1,2*d-p)}}if(D(t,{errors:y+1,currentLocation:d,expectedLocation:d,distance:r,ignoreLocation:a})>g)break;N=O}const V={isMatch:p>=0,score:Math.max(.001,L)};if(m){const y=fe(b,o);y.length?h&&(V.indices=y):V.isMatch=!1}return V}function ge(e){let t={};for(let n=0,s=e.length;n<s;n+=1){const r=e.charAt(n);t[r]=(t[r]||0)|1<<s-n-1}return t}class Lt{constructor(t,{location:n=f.location,threshold:s=f.threshold,distance:r=f.distance,includeMatches:i=f.includeMatches,findAllMatches:c=f.findAllMatches,minMatchCharLength:o=f.minMatchCharLength,isCaseSensitive:h=f.isCaseSensitive,ignoreLocation:a=f.ignoreLocation}={}){if(this.options={location:n,threshold:s,distance:r,includeMatches:i,findAllMatches:c,minMatchCharLength:o,isCaseSensitive:h,ignoreLocation:a},this.pattern=h?t:t.toLowerCase(),this.chunks=[],!this.pattern.length)return;const l=(d,g)=>{this.chunks.push({pattern:d,alphabet:ge(d),startIndex:g})},u=this.pattern.length;if(u>k){let d=0;const g=u%k,p=u-g;for(;d<p;)l(this.pattern.substr(d,k),d),d+=k;if(g){const m=u-k;l(this.pattern.substr(m),m)}}else l(this.pattern,0)}searchIn(t){const{isCaseSensitive:n,includeMatches:s}=this.options;if(n||(t=t.toLowerCase()),this.pattern===t){let p={isMatch:!0,score:0};return s&&(p.indices=[[0,t.length-1]]),p}const{location:r,distance:i,threshold:c,findAllMatches:o,minMatchCharLength:h,ignoreLocation:a}=this.options;let l=[],u=0,d=!1;this.chunks.forEach(({pattern:p,alphabet:m,startIndex:b})=>{const{isMatch:M,score:N,indices:L}=de(t,p,m,{location:r+b,distance:i,threshold:c,findAllMatches:o,minMatchCharLength:h,includeMatches:s,ignoreLocation:a});M&&(d=!0),u+=N,M&&L&&(l=[...l,...L])});let g={isMatch:d,score:d?u/this.chunks.length:1};return d&&s&&(g.indices=l),g}}class w{constructor(t){this.pattern=t}static isMultiMatch(t){return gt(t,this.multiRegex)}static isSingleMatch(t){return gt(t,this.singleRegex)}search(){}}function gt(e,t){const n=e.match(t);return n?n[1]:null}class pe extends w{constructor(t){super(t)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(t){const n=t===this.pattern;return{isMatch:n,score:n?0:1,indices:[0,this.pattern.length-1]}}}class _e extends w{constructor(t){super(t)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(t){const s=t.indexOf(this.pattern)===-1;return{isMatch:s,score:s?0:1,indices:[0,t.length-1]}}}class me extends w{constructor(t){super(t)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(t){const n=t.startsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,this.pattern.length-1]}}}class ye extends w{constructor(t){super(t)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(t){const n=!t.startsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,t.length-1]}}}class xe extends w{constructor(t){super(t)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(t){const n=t.endsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[t.length-this.pattern.length,t.length-1]}}}class Me extends w{constructor(t){super(t)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(t){const n=!t.endsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,t.length-1]}}}class $t extends w{constructor(t,{location:n=f.location,threshold:s=f.threshold,distance:r=f.distance,includeMatches:i=f.includeMatches,findAllMatches:c=f.findAllMatches,minMatchCharLength:o=f.minMatchCharLength,isCaseSensitive:h=f.isCaseSensitive,ignoreLocation:a=f.ignoreLocation}={}){super(t);this._bitapSearch=new Lt(t,{location:n,threshold:s,distance:r,includeMatches:i,findAllMatches:c,minMatchCharLength:o,isCaseSensitive:h,ignoreLocation:a})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(t){return this._bitapSearch.searchIn(t)}}class kt extends w{constructor(t){super(t)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(t){let n=0,s;const r=[],i=this.pattern.length;for(;(s=t.indexOf(this.pattern,n))>-1;)n=s+i,r.push([s,n-1]);const c=!!r.length;return{isMatch:c,score:c?0:1,indices:r}}}const Z=[pe,kt,me,ye,Me,xe,_e,$t],pt=Z.length,Ee=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/,Ie="|";function Ae(e,t={}){return e.split(Ie).map(n=>{let s=n.trim().split(Ee).filter(i=>i&&!!i.trim()),r=[];for(let i=0,c=s.length;i<c;i+=1){const o=s[i];let h=!1,a=-1;for(;!h&&++a<pt;){const l=Z[a];let u=l.isMultiMatch(o);u&&(r.push(new l(u,t)),h=!0)}if(!h)for(a=-1;++a<pt;){const l=Z[a];let u=l.isSingleMatch(o);if(u){r.push(new l(u,t));break}}}return r})}const Se=new Set([$t.type,kt.type]);class we{constructor(t,{isCaseSensitive:n=f.isCaseSensitive,includeMatches:s=f.includeMatches,minMatchCharLength:r=f.minMatchCharLength,ignoreLocation:i=f.ignoreLocation,findAllMatches:c=f.findAllMatches,location:o=f.location,threshold:h=f.threshold,distance:a=f.distance}={}){this.query=null,this.options={isCaseSensitive:n,includeMatches:s,minMatchCharLength:r,findAllMatches:c,ignoreLocation:i,location:o,threshold:h,distance:a},this.pattern=n?t:t.toLowerCase(),this.query=Ae(this.pattern,this.options)}static condition(t,n){return n.useExtendedSearch}searchIn(t){const n=this.query;if(!n)return{isMatch:!1,score:1};const{includeMatches:s,isCaseSensitive:r}=this.options;t=r?t:t.toLowerCase();let i=0,c=[],o=0;for(let h=0,a=n.length;h<a;h+=1){const l=n[h];c.length=0,i=0;for(let u=0,d=l.length;u<d;u+=1){const g=l[u],{isMatch:p,indices:m,score:b}=g.search(t);if(p){if(i+=1,o+=b,s){const M=g.constructor.type;Se.has(M)?c=[...c,...m]:c.push(m)}}else{o=0,i=0,c.length=0;break}}if(i){let u={isMatch:!0,score:o/i};return s&&(u.indices=c),u}}return{isMatch:!1,score:1}}}const q=[];function be(...e){q.push(...e)}function tt(e,t){for(let n=0,s=q.length;n<s;n+=1){let r=q[n];if(r.condition(e,t))return new r(e,t)}return new Lt(e,t)}const H={AND:"$and",OR:"$or"},et={PATH:"$path",PATTERN:"$val"},nt=e=>!!(e[H.AND]||e[H.OR]),Le=e=>!!e[et.PATH],$e=e=>!I(e)&&At(e)&&!nt(e),_t=e=>({[H.AND]:Object.keys(e).map(t=>({[t]:e[t]}))});function Rt(e,t,{auto:n=!0}={}){const s=r=>{let i=Object.keys(r);const c=Le(r);if(!c&&i.length>1&&!nt(r))return s(_t(r));if($e(r)){const h=c?r[et.PATH]:i[0],a=c?r[et.PATTERN]:r[h];if(!E(a))throw new Error(qt(h));const l={keyId:J(h),pattern:a};return n&&(l.searcher=tt(a,t)),l}let o={children:[],operator:i[0]};return i.forEach(h=>{const a=r[h];I(a)&&a.forEach(l=>{o.children.push(s(l))})}),o};return nt(e)||(e=_t(e)),s(e)}function ke(e,{ignoreFieldNorm:t=f.ignoreFieldNorm}){e.forEach(n=>{let s=1;n.matches.forEach(({key:r,norm:i,score:c})=>{const o=r?r.weight:null;s*=Math.pow(c===0&&o?Number.EPSILON:c,(o||1)*(t?1:i))}),n.score=s})}function Re(e,t){const n=e.matches;t.matches=[],!!_(n)&&n.forEach(s=>{if(!_(s.indices)||!s.indices.length)return;const{indices:r,value:i}=s;let c={indices:r,value:i};s.key&&(c.key=s.key.src),s.idx>-1&&(c.refIndex=s.idx),t.matches.push(c)})}function Ne(e,t){t.score=e.score}function Oe(e,t,{includeMatches:n=f.includeMatches,includeScore:s=f.includeScore}={}){const r=[];return n&&r.push(Re),s&&r.push(Ne),e.map(i=>{const{idx:c}=i,o={item:t[c],refIndex:c};return r.length&&r.forEach(h=>{h(i,o)}),o})}class j{constructor(t,n={},s){this.options=$($({},f),n),this.options.useExtendedSearch,this._keyStore=new se(this.options.keys),this.setCollection(t,s)}setCollection(t,n){if(this._docs=t,n&&!(n instanceof rt))throw new Error(Zt);this._myIndex=n||bt(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(t){!_(t)||(this._docs.push(t),this._myIndex.add(t))}remove(t=()=>!1){const n=[];for(let s=0,r=this._docs.length;s<r;s+=1){const i=this._docs[s];t(i,s)&&(this.removeAt(s),s-=1,r-=1,n.push(i))}return n}removeAt(t){this._docs.splice(t,1),this._myIndex.removeAt(t)}getIndex(){return this._myIndex}search(t,{limit:n=-1}={}){const{includeMatches:s,includeScore:r,shouldSort:i,sortFn:c,ignoreFieldNorm:o}=this.options;let h=E(t)?E(this._docs[0])?this._searchStringList(t):this._searchObjectList(t):this._searchLogical(t);return ke(h,{ignoreFieldNorm:o}),i&&h.sort(c),It(n)&&n>-1&&(h=h.slice(0,n)),Oe(h,this._docs,{includeMatches:s,includeScore:r})}_searchStringList(t){const n=tt(t,this.options),{records:s}=this._myIndex,r=[];return s.forEach(({v:i,i:c,n:o})=>{if(!_(i))return;const{isMatch:h,score:a,indices:l}=n.searchIn(i);h&&r.push({item:i,idx:c,matches:[{score:a,value:i,norm:o,indices:l}]})}),r}_searchLogical(t){const n=Rt(t,this.options),s=(o,h,a)=>{if(!o.children){const{keyId:u,searcher:d}=o,g=this._findMatches({key:this._keyStore.get(u),value:this._myIndex.getValueForItemAtKeyId(h,u),searcher:d});return g&&g.length?[{idx:a,item:h,matches:g}]:[]}const l=[];for(let u=0,d=o.children.length;u<d;u+=1){const g=o.children[u],p=s(g,h,a);if(p.length)l.push(...p);else if(o.operator===H.AND)return[]}return l},r=this._myIndex.records,i={},c=[];return r.forEach(({$:o,i:h})=>{if(_(o)){let a=s(n,o,h);a.length&&(i[h]||(i[h]={idx:h,item:o,matches:[]},c.push(i[h])),a.forEach(({matches:l})=>{i[h].matches.push(...l)}))}}),c}_searchObjectList(t){const n=tt(t,this.options),{keys:s,records:r}=this._myIndex,i=[];return r.forEach(({$:c,i:o})=>{if(!_(c))return;let h=[];s.forEach((a,l)=>{h.push(...this._findMatches({key:a,value:c[l],searcher:n}))}),h.length&&i.push({idx:o,item:c,matches:h})}),i}_findMatches({key:t,value:n,searcher:s}){if(!_(n))return[];let r=[];if(I(n))n.forEach(({v:i,i:c,n:o})=>{if(!_(i))return;const{isMatch:h,score:a,indices:l}=s.searchIn(i);h&&r.push({score:a,key:t,value:i,idx:c,norm:o,indices:l})});else{const{v:i,n:c}=n,{isMatch:o,score:h,indices:a}=s.searchIn(i);o&&r.push({score:h,key:t,value:i,norm:c,indices:a})}return r}}j.version="6.5.3";j.createIndex=bt;j.parseIndex=ue;j.config=f;j.parseQuery=Rt;be(we);export{Je as A,Ze as B,j as F,nn as S,Qe as a,ze as b,Fe as c,Pt as d,Ve as e,Pe as f,Be as g,qe as h,en as i,tn as j,Vt as k,Ye as l,Ht as m,mt as n,Mt as o,We as p,je as q,Ue as r,Te as s,zt as t,Ke as u,T as v,De as w,Xe as x,He as y,Ge as z};
